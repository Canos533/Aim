import React, { useEffect, useRef, useState } from "react";

/**
 * Valorant Sensitivity Finder — Browser-based
 *
 * NOTE (bugfix): The previous version attempted to call `requestPointerLock()`
 * without handling the case where the hosting frame is sandboxed (Canvas/iframe).
 * In that situation browsers throw a SecurityError: "Blocked pointer lock on an
 * element because the element's frame is sandboxed and the 'allow-pointer-lock'
 * permission is not set.".
 *
 * Fix strategy in this file:
 * - Wrap `requestPointerLock()` in try/catch and gracefully fall back when it fails.
 * - Provide a robust fallback "Mouse Tracking" mode that works inside sandboxed
 *   iframes: the cursor follows the mouse inside the arena (no relative movement).
 * - Show a clear UI message when pointer lock is unavailable and offer to open
 *   the app in a new tab (where pointer lock is usually allowed).
 *
 * This preserves the original behavior when pointer lock is allowed, and avoids
 * uncaught exceptions when it is blocked.
 */

const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

function Crosshair({ x, y }) {
  return (
    <div
      className="pointer-events-none absolute w-0 h-0"
      style={{ left: x, top: y }}
    >
      <div className="absolute -left-4 w-8 h-[2px] bg-white/90" />
      <div className="absolute -top-4 h-8 w-[2px] bg-white/90" />
      <div className="absolute -left-[1px] -top-[1px] w-[2px] h-[2px] bg-fuchsia-400 shadow-[0_0_8px_#f0f]" />
    </div>
  );
}

function Target({ x, y, r }) {
  return (
    <div
      className="absolute rounded-full border-2 border-white/80 bg-white/10"
      style={{ left: x - r, top: y - r, width: r * 2, height: r * 2 }}
    />
  );
}

function Stat({ label, value, sub }) {
  return (
    <div className="p-3 rounded-2xl bg-white/5 border border-white/10">
      <div className="text-xs uppercase tracking-wider text-white/60">{label}</div>
      <div className="text-xl font-semibold">{value}</div>
      {sub && <div className="text-xs text-white/60">{sub}</div>}
    </div>
  );
}

function Card({ children, className = "" }) {
  return (
    <div className={`rounded-2xl border border-white/10 bg-white/5 p-4 shadow-xl ${className}`}>
      {children}
    </div>
  );
}

const defaultSensList = [0.28, 0.32, 0.36, 0.40, 0.44, 0.50, 0.56, 0.62, 0.70, 0.80].map(n => Number(n.toFixed(2)));

export default function App() {
  const arenaRef = useRef(null);
  const [arena, setArena] = useState({ w: 800, h: 500, padding: 24 });
  const [dpi, setDpi] = useState(800);
  const [sensListText, setSensListText] = useState(defaultSensList.join(", "));
  const [sensList, setSensList] = useState(defaultSensList);
  const [currentSensIndex, setCurrentSensIndex] = useState(-1);
  const [currentSens, setCurrentSens] = useState(null);
  const [roundSettings, setRoundSettings] = useState({ targets: 12, targetR: 18, interSpawnMs: [250, 1400] });
  const [running, setRunning] = useState(false);
  const [cursor, setCursor] = useState({ x: 400, y: 250 });
  const [spawn, setSpawn] = useState(null); // {x,y,r,ts}
  const [shots, setShots] = useState([]); // {sens, hit, timeMs, dist}
  const [targetsLeft, setTargetsLeft] = useState(0);
  const [lastSpawnTs, setLastSpawnTs] = useState(0);

  // Pointer lock feature flags / UI states
  const supportsPointerLock = typeof HTMLElement !== 'undefined' && 'requestPointerLock' in HTMLElement.prototype;
  const [usePointerLock, setUsePointerLock] = useState(true); // user preference
  const [pointerLockActive, setPointerLockActive] = useState(false); // whether pointer lock is currently held
  const [pointerLockError, setPointerLockError] = useState(null); // message when lock fails

  // Update sens list from text
  useEffect(() => {
    const nums = sensListText
      .split(/[,\s]+/)
      .map(s => Number(s))
      .filter(n => !isNaN(n) && n > 0 && n < 5)
      .slice(0, 20);
    if (nums.length) setSensList(nums);
  }, [sensListText]);

  // Resize observer for arena
  useEffect(() => {
    const ro = new ResizeObserver(entries => {
      for (const e of entries) {
        const rect = e.contentRect;
        setArena(a => ({ ...a, w: Math.floor(rect.width), h: Math.floor(rect.height) }));
      }
    });
    if (arenaRef.current) ro.observe(arenaRef.current);
    return () => ro.disconnect();
  }, []);

  // Pointer lock change listener — update active state
  useEffect(() => {
    function onPointerLockChange() {
      setPointerLockActive(document.pointerLockElement === arenaRef.current);
    }
    document.addEventListener('pointerlockchange', onPointerLockChange);
    return () => document.removeEventListener('pointerlockchange', onPointerLockChange);
  }, []);

  // Movement handling: two modes
  // 1) Pointer Lock active -> use window mousemove movementX/Y
  // 2) Fallback mouse tracking -> use arena onMouseMove absolute coordinates

  // pointer lock movement
  useEffect(() => {
    function onWindowMove(e) {
      if (!pointerLockActive || !running) return;
      // scale the relative movement by sensitivity (preserve previous scale behaviour)
      const scale = 0.075 + (currentSens ?? 0) * 0.925;
      setCursor(c => ({
        x: clamp(c.x + e.movementX * scale, arena.padding, arena.w - arena.padding),
        y: clamp(c.y + e.movementY * scale, arena.padding, arena.h - arena.padding),
      }));
    }
    window.addEventListener('mousemove', onWindowMove);
    return () => window.removeEventListener('mousemove', onWindowMove);
  }, [pointerLockActive, running, currentSens, arena]);

  // Start / stop test
  function startTest() {
    setShots([]);
    setCurrentSensIndex(0);
    setCurrentSens(sensList[0]);
    setTargetsLeft(roundSettings.targets);
    setRunning(true);
    setSpawn(null);
    setCursor({ x: arena.w / 2, y: arena.h / 2 });
    setLastSpawnTs(0);
    // reset any previous pointer lock error
    setPointerLockError(null);
  }

  function stopTest() {
    setRunning(false);
    // exit pointer lock if active
    try { document.exitPointerLock?.(); } catch (e) { /* ignore */ }
    setSpawn(null);
    setTargetsLeft(0);
    setCurrentSensIndex(-1);
    setCurrentSens(null);
  }

  // Arena click handler: either attempt to request pointer lock (first click)
  // or record a shot if pointer lock is active or mouse-tracking mode is used.
  function handleArenaClick(e) {
    // If user wants pointer lock and the environment supports it but it's not active,
    // try to request pointer lock. Wrap in try/catch to avoid SecurityError crash.
    if (usePointerLock && supportsPointerLock && !pointerLockActive) {
      const el = arenaRef.current;
      if (el) {
        try {
          el.requestPointerLock();
          // In most browsers this will trigger a pointerlockchange event we listen for.
          setPointerLockError(null);
        } catch (err) {
          // Browser blocked pointer lock (e.g. sandboxed iframe) — fallback to mouse mode
          setPointerLockError(String(err?.message || err));
          setUsePointerLock(false); // switch to fallback automatically
        }
      }
      return; // first click is for locking — don't count as a shot
    }

    if (!running || !spawn) return;

    // In mouse-tracking mode the cursor position is absolute (updated via onMouseMove)
    const d = distance(cursor.x, cursor.y, spawn.x, spawn.y);
    const hit = d <= spawn.r;
    const timeMs = performance.now() - spawn.ts;
    recordShot(hit, timeMs, hit ? 0 : d - spawn.r);
  }

  // For fallback mouse-tracking mode we update cursor position using absolute coords.
  function handleArenaMouseMove(e) {
    // If pointer lock is active we ignore arena mousemove (we handle movement via window mousemove)
    if (pointerLockActive) return;
    if (!arenaRef.current) return;
    const rect = arenaRef.current.getBoundingClientRect();
    const x = clamp(e.clientX - rect.left, arena.padding, arena.w - arena.padding);
    const y = clamp(e.clientY - rect.top, arena.padding, arena.h - arena.padding);
    setCursor({ x, y });
  }

  // Spawn logic
  useEffect(() => {
    if (!running) return;
    if (targetsLeft <= 0) return;

    if (!spawn) {
      const [min, max] = roundSettings.interSpawnMs;
      const delay = Math.random() * (max - min) + min;
      const handle = setTimeout(() => {
        const r = roundSettings.targetR;
        const x = Math.random() * (arena.w - 2 * (arena.padding + r)) + arena.padding + r;
        const y = Math.random() * (arena.h - 2 * (arena.padding + r)) + arena.padding + r;
        setSpawn({ x, y, r, ts: performance.now() });
        setLastSpawnTs(performance.now());
      }, delay);
      return () => clearTimeout(handle);
    } else {
      const ttl = 2500;
      const handle = setTimeout(() => {
        recordShot(false, ttl, distance(cursor.x, cursor.y, spawn.x, spawn.y) - spawn.r);
      }, ttl);
      return () => clearTimeout(handle);
    }
  }, [running, spawn, targetsLeft, arena, roundSettings, cursor]);

  function distance(x1, y1, x2, y2) {
    const dx = x1 - x2;
    const dy = y1 - y2;
    return Math.hypot(dx, dy);
  }

  function recordShot(hit, timeMs, missDistPx) {
    if (!running) return;
    setShots(s => [...s, { sens: currentSens, hit, timeMs, dist: hit ? 0 : Math.max(0, missDistPx) }]);
    setSpawn(null);
    setTargetsLeft(n => n - 1);
  }

  // When a round ends for a given sens, move to next
  useEffect(() => {
    if (!running) return;
    if (targetsLeft > 0) return;

    const next = currentSensIndex + 1;
    if (next < sensList.length) {
      setCurrentSensIndex(next);
      setCurrentSens(sensList[next]);
      setTargetsLeft(roundSettings.targets);
      setSpawn(null);
      setCursor({ x: arena.w / 2, y: arena.h / 2 });
    } else {
      setRunning(false);
      try { document.exitPointerLock?.(); } catch (e) { /* ignore */ }
    }
  }, [targetsLeft, running, currentSensIndex, sensList, roundSettings.targets, arena]);

  // Aggregate results + recommendation (same as before)
  const results = aggregate(shots);
  const best = pickBest(results);

  return (
    <div className="min-h-screen text-white bg-gradient-to-br from-slate-900 via-slate-950 to-black">
      <div className="max-w-6xl mx-auto p-4 md:p-8">
        <header className="mb-6 flex items-center justify-between gap-4">
          <h1 className="text-2xl md:text-3xl font-bold tracking-tight">Valorant Sensitivity Finder</h1>
          <div className="text-white/70 text-sm">Tarayıcı üzerinde aim testi • Pointer Lock (varsa) veya Mouse Tracking</div>
        </header>

        <div className="grid md:grid-cols-3 gap-4 mb-6">
          <Card>
            <div className="text-sm font-semibold mb-2">1) Aday hassasiyetler</div>
            <textarea
              className="w-full h-24 rounded-xl bg-white/10 border border-white/10 p-3 text-sm focus:outline-none"
              value={sensListText}
              onChange={e => setSensListText(e.target.value)}
            />
            <div className="text-xs text-white/60 mt-2">Virgül veya boşlukla ayır (örn: 0.32, 0.36, 0.40, 0.44 ...)</div>
          </Card>

          <Card>
            <div className="text-sm font-semibold mb-2">2) Test ayarları</div>
            <div className="grid grid-cols-2 gap-3 text-sm">
              <label className="flex flex-col gap-1">
                <span>Hedef sayısı/round</span>
                <input
                  type="number"
                  min={6}
                  max={40}
                  className="rounded-xl bg-white/10 border border-white/10 p-2"
                  value={roundSettings.targets}
                  onChange={e => setRoundSettings({ ...roundSettings, targets: clamp(Number(e.target.value||12), 6, 40) })}
                />
              </label>
              <label className="flex flex-col gap-1">
                <span>Hedef yarıçapı (px)</span>
                <input
                  type="number"
                  min={8}
                  max={40}
                  className="rounded-xl bg-white/10 border border-white/10 p-2"
                  value={roundSettings.targetR}
                  onChange={e => setRoundSettings({ ...roundSettings, targetR: clamp(Number(e.target.value||18), 8, 40) })}
                />
              </label>
              <label className="flex flex-col gap-1 col-span-2">
                <span>Spawn aralığı (ms) min–max</span>
                <div className="flex gap-2">
                  <input
                    type="number"
                    className="w-1/2 rounded-xl bg-white/10 border border-white/10 p-2"
                    value={roundSettings.interSpawnMs[0]}
                    onChange={e => setRoundSettings({ ...roundSettings, interSpawnMs: [clamp(Number(e.target.value||250), 0, 3000), roundSettings.interSpawnMs[1]] })}
                  />
                  <input
                    type="number"
                    className="w-1/2 rounded-xl bg-white/10 border border-white/10 p-2"
                    value={roundSettings.interSpawnMs[1]}
                    onChange={e => setRoundSettings({ ...roundSettings, interSpawnMs: [roundSettings.interSpawnMs[0], clamp(Number(e.target.value||1400), 200, 5000)] })}
                  />
                </div>
              </label>
            </div>
          </Card>

          <Card>
            <div className="text-sm font-semibold mb-2">3) Donanım (referans)</div>
            <label className="flex flex-col gap-1 text-sm">
              <span>DPI (gerçek faren)</span>
              <input
                type="number"
                min={100}
                max={32000}
                className="rounded-xl bg-white/10 border border-white/10 p-2"
                value={dpi}
                onChange={e => setDpi(clamp(Number(e.target.value||800), 100, 32000))}
              />
            </label>
            <div className="text-xs text-white/60 mt-2">eDPI = DPI × Sens
            <br/>Örn: 800 DPI ve 0.4 sens ⇒ 320 eDPI</div>
          </Card>
        </div>

        <div className="grid md:grid-cols-3 gap-4">
          <Card className="md:col-span-2">
            <div className="flex items-center justify-between mb-3">
              <div className="flex items-center gap-3">
                <button
                  onClick={running ? stopTest : startTest}
                  className={`px-4 py-2 rounded-xl font-semibold shadow ${running ? "bg-rose-500 hover:bg-rose-600" : "bg-emerald-500 hover:bg-emerald-600"}`}
                >
                  {running ? "Durdur" : "Teste Başla"}
                </button>
                <div className="text-sm text-white/70">{running ? `Round: ${currentSensIndex+1}/${sensList.length} • Sens: ${currentSens?.toFixed(2)}` : "Hazır"}</div>
              </div>

              <div className="flex items-center gap-3">
                <label className="text-xs text-white/60 flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={usePointerLock}
                    onChange={e => setUsePointerLock(e.target.checked)}
                    disabled={!supportsPointerLock}
                    className="w-4 h-4"
                  />
                  <span>Pointer Lock (varsa)</span>
                </label>
                <div className="text-xs text-white/60">Tıklayıp imleci kilitle (varsa) veya normal fare takibi kullan.</div>
              </div>
            </div>

            {/* Arena */}
            <div
              ref={arenaRef}
              onClick={handleArenaClick}
              onMouseMove={handleArenaMouseMove}
              className="relative rounded-2xl border border-white/10 bg-gradient-to-tr from-slate-800 to-slate-900 overflow-hidden select-none"
              style={{ height: 520 }}
            >
              {/* Padding boundaries */}
              <div className="absolute inset-0 border-2 border-dashed border-white/10 rounded-2xl pointer-events-none" style={{
                margin: arena.padding,
              }} />

              {spawn && <Target x={spawn.x} y={spawn.y} r={spawn.r} />}
              <Crosshair x={cursor.x} y={cursor.y} />

              {/* Pointer lock warning if it failed */}
              {pointerLockError && (
                <div className="absolute top-4 left-4 right-4 bg-rose-800/80 border border-rose-600 p-3 rounded-lg text-sm">
                  <div className="font-semibold">Pointer Lock engellendi</div>
                  <div className="text-xs mt-1">Tarayıcı veya barındırma çerçevesi pointer lock izni vermiyor. Bu ortamda pointer lock kullanılamıyor.</div>
                  <div className="flex gap-2 mt-2">
                    <button className="px-3 py-1 rounded bg-rose-600" onClick={() => setPointerLockError(null)}>Kapat</button>
                    <button className="px-3 py-1 rounded bg-emerald-600" onClick={() => window.open(window.location.href, "_blank")}>Yeni sekmede aç</button>
                  </div>
                </div>
              )}

              {!running && (
                <div className="absolute inset-0 flex items-center justify-center">
                  <div className="text-center max-w-md">
                    <div className="text-2xl font-semibold mb-2">Hazır mısın?</div>
                    <p className="text-white/70 mb-4">Teste başlamadan önce aday sens değerlerini gözden geçir. Başla'ya bastıktan sonra bu alana tıklayıp mouse'u kilitle (pointer lock etkinse) veya normal modda hedefleri vur.</p>
                    <div className="text-sm text-white/60">İpucu: Sonuçtan memnun değilsen listeyi daraltıp (örn. 0.34–0.44) ikinci tur ince ayar yap.</div>
                  </div>
                </div>
              )}
            </div>
          </Card>

          <Card>
            <div className="text-sm font-semibold mb-3">Anlık Durum</div>
            <div className="grid grid-cols-2 gap-3">
              <Stat label="Sens" value={currentSens ? currentSens.toFixed(2) : "-"} sub="Şu an test edilen" />
              <Stat label="eDPI" value={currentSens ? Math.round(dpi * currentSens) : "-"} sub={`${dpi} DPI`} />
              <Stat label="Kalan hedef" value={running ? String(targetsLeft) : "-"} />
              <Stat label="Toplam isabet" value={String(shots.filter(s => s.hit).length)} />
            </div>
          </Card>
        </div>

        <div className="mt-6 grid md:grid-cols-2 gap-4">
          <Card>
            <div className="text-sm font-semibold mb-3">Skor Tablosu</div>
            <ResultTable results={results} dpi={dpi} />
          </Card>
          <Card>
            <div className="text-sm font-semibold mb-3">Öneri</div>
            {best ? (
              <div>
                <div className="text-lg font-semibold">Önerilen Sens: <span className="text-emerald-400">{best.sens.toFixed(2)}</span></div>
                <div className="text-sm text-white/80 mt-1">Bunu Valorant'ta <b>General → Sensitivity: Aim</b> alanına gir. (eDPI ≈ {Math.round(best.sens * dpi)})</div>
                <ul className="text-sm text-white/70 list-disc ml-5 mt-3 space-y-1">
                  <li>Skor, <i>isabet</i> ve <i>zaman</i> dengesine göre hesaplanır.</li>
                  <li>İkinci tur için listeyi {Math.max(0.01, best.sens-0.06).toFixed(2)}–{(best.sens+0.06).toFixed(2)} aralığında 0.02 adımla daralt.</li>
                  <li>Oyun içi ince ayar: önerinin ±0.02 çevresini dene.</li>
                </ul>
              </div>
            ) : (
              <div className="text-white/60">Skor oluşması için test bitmeli.</div>
            )}
          </Card>
        </div>

        <footer className="mt-8 text-xs text-white/50">
          <div>Not: Eğer "Pointer Lock engellendi" uyarısı alıyorsan, uygulamayı yeni bir sekmede açıp deneyin; bazı embed/iframe ortamları pointer lock'u engeller. Bu araç kıyaslama amaçlıdır. Nihai ayarı oyunda doğrula.</div>
        </footer>
      </div>
    </div>
  );
}

function aggregate(shots) {
  const map = new Map();
  for (const s of shots) {
    const g = map.get(s.sens) || { sens: s.sens, total: 0, hits: 0, misses: 0, times: [], avgTime: null, acc: 0, score: 0 };
    g.total += 1;
    if (s.hit) {
      g.hits += 1;
      g.times.push(s.timeMs);
    } else {
      g.misses += 1;
    }
    map.set(s.sens, g);
  }

  const rows = Array.from(map.values()).map(g => {
    const avgTime = g.times.length ? g.times.reduce((a,b)=>a+b,0) / g.times.length : null;
    const acc = g.total ? g.hits / g.total : 0;
    const tNorm = avgTime==null ? 0 : 1 - clamp((avgTime - 300) / (1700), 0, 1);
    const aNorm = acc;
    const score = (aNorm * 0.65 + tNorm * 0.35) * (g.total >= 6 ? 1 : 0.6);
    return { ...g, avgTime, acc, score };
  });

  rows.sort((a, b) => a.sens - b.sens);
  return rows;
}

function pickBest(results) {
  if (!results.length) return null;
  const copy = [...results].filter(r => r.total > 0);
  if (!copy.length) return null;
  copy.sort((a, b) => {
    if (b.score !== a.score) return b.score - a.score;
    if (b.acc !== a.acc) return b.acc - a.acc;
    const ta = a.avgTime ?? Infinity;
    const tb = b.avgTime ?? Infinity;
    return ta - tb;
  });
  return copy[0];
}

function ResultTable({ results, dpi }) {
  if (!results.length) return (
    <div className="text-white/60">Henüz veri yok. Testi bitirince burada görünecek.</div>
  );

  return (
    <div className="overflow-x-auto">
      <table className="w-full text-sm text-left">
        <thead className="text-white/70">
          <tr>
            <th className="py-2 pr-4">Sens</th>
            <th className="py-2 pr-4">eDPI</th>
            <th className="py-2 pr-4">Isabet</th>
            <th className="py-2 pr-4">Ortalama süre</th>
            <th className="py-2 pr-4">Skor</th>
          </tr>
        </thead>
        <tbody>
          {results.map(r => (
            <tr key={r.sens} className="border-t border-white/10">
              <td className="py-2 pr-4 font-medium">{r.sens.toFixed(2)}</td>
              <td className="py-2 pr-4">{Math.round(r.sens * dpi)}</td>
              <td className="py-2 pr-4">{r.hits}/{r.total} ({Math.round(r.acc*100)}%)</td>
              <td className="py-2 pr-4">{r.avgTime ? `${Math.round(r.avgTime)} ms` : "-"}</td>
              <td className="py-2 pr-4">{(r.score*100).toFixed(1)}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
